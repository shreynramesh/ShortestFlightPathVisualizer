package com.mycompany.app;

import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

public class AirportGraph extends CS400Graph<IAirport> implements IAirportGraph {

    IAirportTrie airportTrie;

    Hashtable<String, IAirport> airportHashtable = new Hashtable<>();

    /**
     * Constructor initializes vertices
     * 
     */
    public AirportGraph() {
        vertices = new Hashtable<>();
    }

    /**
     * Uses GraphADT to load airports from Data Wrangler into the graph. Each
     * airport has an array of IRoutes/edges (routes to other airports that are
     * randomly generated by the Data Wrangler). This array will be used to add
     * edges to this graph.
     * 
     * @param source      where the user is starting from
     * @param destination where the user is trying to go
     * @param allAirports an array of Airports provided by the Data Wrangler
     * @param aLoader     an instance of the AirplaneLoader class which give access
     *                    to the loadRoutes method
     */
    @Override
    public void loadGraph(IAirport source, IAirport destination, ArrayList<IAirport> allAirports,
            IAirportLoader aLoader) {
        aLoader.loadRoutes(source, destination);

        for (IAirport vertex : allAirports) { // Adding each airport as a vertex in the graph
            insertVertex(vertex);
            // airportHashtable.put(source.toTrieString(), source);
        }

        for (IAirport vertex : allAirports) { // Adding each airport in each airport's route array as edges
            for (IAirport edge : vertex.getRoutes()) {
                insertEdge(vertex, edge, calculateDistanceBetweenAirports(vertex, edge));
            }
        }

        // Creating Trie for airport names
//        airportTrie = new AirportTrie();
//
//        for (IAirport name : allAirports) {
//            airportTrie.insert(name.toTrieString());
//        }

    }

    /**
     * A temporary method that is being used for testing the AirportGraph. Each
     * airport has an array of IRoutes/edges (routes to other airports that are
     * randomly generated by the Data Wrangler).
     * 
     * @param allAirports an array of Airports provided by the Data Wrangler
     */
    public void temporaryLoadGraph(ArrayList<IAirport> allAirports) {
        for (IAirport source : allAirports) { // Adding each airport as a vertex in the graph
            insertVertex(source);
        }

        for (IAirport source : allAirports) { // Adding each airport in each airport's route array as edges
            for (IAirport destination : source.getRoutes()) {
                insertEdge(source, destination, calculateDistanceBetweenAirports(source, destination));
            }
        }

        // Creating Trie for airport names
//        airportTrie = new AirportTrie();
//
//        for (IAirport name : allAirports) {
//            airportTrie.insert(name.toTrieString());
//        }

    }

    /**
     * This method puts all the airports into a hashtable for easy access by name
     * 
     * @param allAirports a list of all the airports
     */
    @Override
    public Hashtable<String, IAirport> loadAirportHashtable(ArrayList<IAirport> allAirports) {
        for (IAirport source : allAirports) { // Adding each airport as a vertex in the graph
            airportHashtable.put(source.toTrieString(), source);
        }
        return airportHashtable;
    }

    /**
     * This method returns the hashtable initialized by loadAirportHashtable()
     * 
     * @return a Hashtable containing all the airports
     */
    public Hashtable<String, IAirport> getAirportHashtable() {
        return airportHashtable;
    }

    /**
     * This method will be called after Dijkstra's Algorithm is called on the
     * AirportGraph. It takes an arrayList of directed vertices, calculates the
     * total distance between them and multiplies it by the speed. Speed =
     * Distance/Time
     * 
     * @param inOrderPath       the directed set of nodes
     * @param averagePlaneSpeed the speed of the plane in km/hr
     * @return a String representation of the time it would take the average
     *         commerical flight to reach its destination
     */
    @Override
    public String calculateflightTime(List<IAirport> inOrderPath, double averagePlaneSpeed) {
        String output = ""; // Holds the final formatted String
        double totalDistance = 0; // Holds the total distance between all the airports in the path

        for (int i = 1; i < inOrderPath.size(); i++) {
            totalDistance += getWeight(inOrderPath.get(i), inOrderPath.get(i - 1));
            double flightTime = getWeight(inOrderPath.get(i), inOrderPath.get(i - 1)) / averagePlaneSpeed;
            output += inOrderPath.get(i - 1).getCity() + ", " + inOrderPath.get(i - 1).getCountry() + " to "
                    + inOrderPath.get(i).getCity() + ", " + inOrderPath.get(i).getCountry() + ": "
                    + formatTime(flightTime)
                    + "\n";
        }

        // Time = Distance (km) / Speed (km/hr)
        return output + "\nTotal Time: " + formatTime(totalDistance / averagePlaneSpeed);
    }

    /**
     * This is a helper method for calculateFlightTime which takes in a decimal time
     * in hours and converts it to a formatted String that contains hours and
     * minutes
     * 
     * @param d time in hours
     * @return a formatted String representing time it takes for a flight to go a
     *         certain distance
     */
    private String formatTime(double d) {
        int hours = (int) Math.floor(d); // Retrieving only the first part of the decimal

        double ratioMinutes = d - Math.floor(d); // Retrieving only the decimal part of the decimal and converting that
                                                 // to a value between 0 - 60 to represent minutes
        int minutes = (int) (60 * ratioMinutes);

        return hours + " hours and " + minutes + " minutes";
    }

    /**
     * This method simply calculates the distance between two Airports. It makes use
     * of the haversine formula as well as the Earth's approximate radius.
     * 
     * @param a1 airport 1
     * @param a2 airport 2
     * @return a double representing the distance between the 2 airports in km.
     */
    @Override
    public int calculateDistanceBetweenAirports(IAirport a1, IAirport a2) {
        double earthRadius = 6357; // Radius of Earth in km

        // Converting decimal degrees to radians
        double a1LatRad = a1.getLatitude() / (180 / Math.PI);
        double a1LongRad = a1.getLongitude() / (180 / Math.PI);

        double a2LatRad = a2.getLatitude() / (180 / Math.PI);
        double a2LongRad = a2.getLongitude() / (180 / Math.PI);

        return (int) Math.round(earthRadius * Math.acos((Math.sin(a1LatRad) * Math.sin(a2LatRad))
                + (Math.cos(a1LatRad) * Math.cos(a2LatRad) * Math.cos(a2LongRad - a1LongRad))));
    }

    /**
     * This method just calls the original remove method except also updates the the
     * the routes array of the source airport.
     */
    @Override
    public boolean removeEdge(IAirport source, IAirport target) {
        source.getRoutes().remove(target);
        return super.removeEdge(source, target);
    }

    /**
     * This method returns an arrayList of airport names that share the same given
     * prefix. This is returned to the frontend which uses the array to display
     * these airports in a dropdown to help the user pick an airport.
     * 
     * @param prefix a string that holds prefix
     * @return an arrayList of Strings which each represent an airport
     */
    @Override
    public ArrayList<String> getAirportsFromTrie(String prefix) {
        return airportTrie.searchPrefix(prefix);
    }

    /**
     * getter for verticies
     * @return hashtable of verticies
     */

    public Hashtable<IAirport, Vertex> getVertices(){
        return this.vertices;
    }
}
